<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./js/pixi.min.js"></script>
    <script src="./js/bump.js"></script>
    <style>
        html {
            overflow: scroll;
            overflow-x: hidden;
        }

        canvas {
            display: block;
        }

        #MYAPP {
            position: absolute;
            overflow: hidden;
            top: 0%;
            left: 0%;
            width: 100%;
            height: 100%;
        }

        ::-webkit-scrollbar {
            width: 0;
            /* Remove scrollbar space */
            background: transparent;
            /* Optional: just make scrollbar invisible */
        }

        /* Optional: show position indicator in red */
        ::-webkit-scrollbar-thumb {
            background: #FF0000;
        }
    </style>
</head>

<body>
    <div id="MYAPP"></div>
    <script>
        let app = new PIXI.Application({ width: window.innerWidth, height: window.innerHeight, autoResize: true, resolution: 1 });
        document.body.appendChild(app.view);
        ctx = app.renderer.context.gl;
        var mouse = app.renderer.plugins.interaction.mouse.global;
        MouseX = mouse.x;
        MouseY = mouse.y;
        let GameContainer = new PIXI.Container();
        var Pacman = null
        PacManDirc = "ArrowRight"
        PacManRight = []
        PacManLeft = []
        var PixelData, collpixels
        PacManSpeed =  window.innerWidth / 500
        PacManMouthRate_MSec = 10
        xmove = 0
        ymove = 0
        PacManUp = []
        lastcorner=null
        var PacManSpriteObj = null
        PacManDown = []
        colorline = []
        Coll2DMapArray = []
        //448 *576
        var changeXmove = 0, chagneYmove = 0, chagnePacManDirc = "ArrowRight"
        const s = PIXI.Loader.shared.add("Gamemap", "/assets/Map/map.png")
            .add("PacmanRight_1", "./assets/Pacman/pacman-right/1.png")
            .add("PacmanRight_2", "./assets/Pacman/pacman-right/2.png")
            .add("PacmanRight_3", "./assets/Pacman/pacman-right/3.png")
            .add("PacmanLeft_1", "./assets/Pacman/pacman-left/1.png")
            .add("PacmanLeft_2", "./assets/Pacman/pacman-left/2.png")
            .add("PacmanLeft_3", "./assets/Pacman/pacman-left/3.png")
            .add("PacmanUp_1", "./assets/Pacman/pacman-up/1.png")
            .add("PacmanUp_2", "./assets/Pacman/pacman-up/2.png")
            .add("PacmanUp_3", "./assets/Pacman/pacman-up/3.png")
            .add("PacmanDown_1", "./assets/Pacman/pacman-down/1.png")
            .add("PacmanDown_2", "./assets/Pacman/pacman-down/2.png")
            .add("PacmanDown_3", "./assets/Pacman/pacman-down/3.png")
            .add("CollusionMap", "./assets/Map/CollusionMap.png")

        function resize() {
            console.log("resize")
            const parent = app.view.parentNode;

            app.renderer.resize(parent.clientWidth, parent.clientHeight);

            Pacman.position.set(
                (GameMap.texture.width - 27) * scalefactorx / 2,
                (GameMap.texture.height + 243) * scalefactory / 2
            );
        }

        s.load(() => {
            GameMap = new PIXI.Sprite(PIXI.Loader.shared.resources.Gamemap.texture);
            scalefactorx = window.innerHeight / GameMap.texture.height;
            scalefactory = window.innerHeight / GameMap.texture.height;
            scalefactorx = parseFloat(scalefactorx.toFixed(2));
            scalefactory = parseFloat(scalefactory.toFixed(2));
            Pacman = new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanRight_1.texture)
            CollusionMap = new PIXI.Sprite(PIXI.Loader.shared.resources.CollusionMap.texture)
            PacManRight.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanRight_1.texture));
            PacManRight.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanRight_2.texture));
            PacManRight.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanRight_3.texture));
            PacManLeft.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanLeft_1.texture));
            PacManLeft.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanLeft_2.texture));
            PacManLeft.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanLeft_3.texture));
            PacManUp.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanUp_1.texture));
            PacManUp.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanUp_2.texture));
            PacManUp.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanUp_3.texture));
            PacManDown.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanDown_1.texture));
            PacManDown.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanDown_2.texture));
            PacManDown.push(new PIXI.Sprite(PIXI.Loader.shared.resources.PacmanDown_3.texture));
            PacManSpriteObj = { "Pacman": [Pacman], "ArrowDown": PacManDown, "ArrowLeft": PacManLeft, "ArrowRight": PacManRight, "ArrowUp": PacManUp }
            collpixels = app.renderer.extract.pixels(CollusionMap)

            GameMap.scale.x *= scalefactorx
            GameMap.scale.y *= scalefactory
            CollusionMap.scale.x *= scalefactorx
            CollusionMap.scale.y *= scalefactory

            GameContainer.addChild(CollusionMap)
            Object.values(PacManSpriteObj).forEach((eachSpriteArray) => {
                eachSpriteArray.forEach((eachSprite) => {
                    eachSprite.scale.x *= scalefactorx * 2
                    eachSprite.scale.y *= scalefactory * 2
                    eachSprite.x = 100
                    eachSprite.y = 700
                })
            })


            for (i = 0; i <= collpixels.length; i += 4) {
                colorline.push(collpixels[i])
                if (colorline.length == 448) {
                    Coll2DMapArray.push(colorline)
                    colorline = []
                }
            }
            console.log(i)
            GameMap.x = 0
            GameMap.y = 0

            GameContainer.addChild(GameMap)


            PacmanRadius = Pacman.width / 2
            // Pacman.anchor.set(12, 10.9);
            GameContainer.addChild(Pacman)
            // app.stage.addChild(gr)

            app.stage.addChild(GameContainer)

            resize();
            app.stage.addChild(graphic);
            app.ticker.add(gameLoop)
            document.body.onkeydown = (key => {
                if (Object.keys(PacManSpriteObj).includes(key.code)) {
                    PacManDirc = key.code
                    switch (PacManDirc) {
                        case "ArrowUp":
                            chagneYmove = -PacManSpeed
                            changeXmove = 0
                            break
                        case "ArrowDown":
                            chagneYmove = PacManSpeed
                            changeXmove = 0
                            break
                        case "ArrowRight":
                            changeXmove = PacManSpeed
                            chagneYmove = 0
                            break
                        case "ArrowLeft":
                            changeXmove = -PacManSpeed
                            chagneYmove = 0
                            break
                    }

                }
            })

        })
        function pixel(mysprite, x, y) {
            var pixels = app.renderer.extract.pixels(mysprite);
            var index = (y * mysprite.width + x) * 4;

            return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]]
        }


        let graphic = new PIXI.Graphics();
        let xp = 0, yp = 0
        timeElapsed = 0
        PacManSkinItrate = 0

        function gameLoop(delta) {
            timeElapsed += delta
            //console.log(   Coll2DMapArray[parseInt((Pacman.y+PacmanRadius)/ scalefactory)][parseInt((Pacman.x+PacmanRadius)/scalefactorx)])
            // check if can change direction or go in same dir 
            if (chagneYmove != ymove || changeXmove != xmove) {
                console.log("aya")

                oneymove= Math.sign(chagneYmove)
                onexmove=Math.sign(changeXmove)
                for(i=1;i<=parseInt((Pacman.width)/2);i++){
                let can_go = Coll2DMapArray[parseInt((Pacman.y + PacmanRadius + (oneymove * i)) / scalefactory)][parseInt((Pacman.x + PacmanRadius + (onexmove *i)) / scalefactorx)]
                if (i==parseInt((Pacman.width)/2) ) {
                    xmove = changeXmove 
                    ymove = chagneYmove
                    chagnePacManDirc = PacManDirc
                    console.log("1",[parseInt((Pacman.y + PacmanRadius + (chagneYmove * i)) / scalefactory)],[parseInt((Pacman.x + PacmanRadius + (changeXmove * i)) / scalefactorx)],xmove,ymove,i)
                    
                }
                if(can_go==0){
                    console.log("2",[parseInt((Pacman.y + PacmanRadius + (chagneYmove * i)) / scalefactory)],[parseInt((Pacman.x + PacmanRadius + (changeXmove * i)) / scalefactorx)],xmove,ymove,i)

                    break
                }
            }
            }
            pacmanWay = Coll2DMapArray[parseInt((Pacman.y + PacmanRadius + (ymove)) / scalefactory)][parseInt((Pacman.x + PacmanRadius + (xmove)) / scalefactorx)]

            if (pacmanWay != 0) {
                //console.log(Pacman.x, Pacman.y)
                Pacman.x += xmove
                Pacman.y += ymove
            }
            else {
                console.log(xmove,ymove)

                oneymove= Math.sign(ymove) 
                onexmove=Math.sign(xmove) 
                console.log(onexmove,oneymove)

                while (lastcorner!=0 && lastcorner<16) {
                    lastcorner = Coll2DMapArray[parseInt((Pacman.y+oneymove + PacmanRadius ) / scalefactory)][parseInt((Pacman.x +onexmove+ PacmanRadius ) / scalefactorx)]
                    if (lastcorner!=0){
                    Pacman.x += onexmove
                    Pacman.y += oneymove
                    console.log(lastcorner,[parseInt((Pacman.y+oneymove + PacmanRadius ) / scalefactory)][parseInt((Pacman.x +onexmove+ PacmanRadius ) / scalefactorx)])
                    }
                    else{ lastcorner=null; break}
                    
                }
                
   
            }
            if (timeElapsed > PacManMouthRate_MSec) {
                if (PacManSkinItrate == 3)
                    PacManSkinItrate = 0
                Pacman.texture = PacManSpriteObj[chagnePacManDirc][PacManSkinItrate].texture
                PacManSkinItrate += 1
                timeElapsed = 0
            }

            graphic.beginFill(0xffffff);
            graphic.drawCircle(Pacman.x + Pacman.width / 2, Pacman.y + Pacman.width / 2, 2);
            graphic.endFill();

        }


    </script>
</body>

</html>